# Персонализированная система рекомендаций товаров

Решение для задачи рекомендации товаров на основе истории взаимодействия пользователей. 

## Датасет
### Исходные данные

Данные представлены в формате Parquet:
- **train.parquet** — история взаимодействия пользователей (3,090,372 записей, ноябрь 2019 - январь 2020)
- **test.parquet** — данные для генерации рекомендаций (247,187 записей, февраль 2020)

### Структура данных

| Столбец | Описание |
|---------|---------|
| event_time | Временная метка события |
| product_id | Идентификатор товара |
| brand | Бренд товара |
| price | Цена товара |
| user_id | Идентификатор пользователя |
| user_session | Идентификатор сессии пользователя |
| cat_0, cat_1, cat_2, cat_3 | Иерархия категорий товара |
| timestamp | Преобразованная временная метка |
| ts_hour, ts_minute, ts_weekday, ts_day, ts_month, ts_year | Темпоральные признаки |

## Методология

### 1. Подготовка данных

- Загрузка и парсинг данных в формате Parquet
- Создание темпоральных признаков из временных меток (час, минута, день недели, день, месяц, год)
- Разбиение на обучающую и валидационную выборки по временному порогу (2020-02-16)
- Применение двухнедельного скользящего окна для корректной валидации

### 2. Метрики оценки

Для оценки качества рекомендаций используются метрики ранжирования:

- **Average Precision at K (AP@K)** — средняя точность для топ-K рекомендаций по отдельному пользователю
- **Mean Average Precision at K (MAP@K)** — усредненная метрика по всей выборке пользователей

Обе метрики учитывают порядок рекомендаций и отсутствие дубликатов в списке.

### 3. Алгоритм рекомендаций

#### Этап 1: Анализ популярности

Вычисляется рейтинг товаров на основе частоты их появления в обучающей выборке:
`popular_products = data_train.groupby(['product_id']).size().sort_values(ascending=False)`

#### Этап 2: Построение профиля пользователя

Для каждого пользователя анализируются:

1. **Предпочтения по брендам** — определяются топ-3 бренда, с которыми взаимодействовал пользователь
2. **Ценовой профиль** — вычисляется средняя цена товаров в истории пользователя
3. **История покупок** — строится набор товаров, уже просмотренных или приобретенных пользователем

#### Этап 3: Персонализованная фильтрация

Для каждого пользователя формируется список рекомендуемых товаров на основе критериев:

- Товар не был ранее приобретен пользователем
- Товар принадлежит одному из предпочитаемых пользователем брендов
- Цена товара находится в диапазоне: \(0.35 \times P_{avg} \leq P_{item} \leq 2.4 \times P_{avg}\), где \(P_{avg}\) — средняя цена товаров пользователя

#### Этап 4: Гибридная стратегия

1. Отобираются топ-3 персонализированные товара из отфильтрованного списка
2. Если персонализированных товаров недостаточно, список дополняется популярными товарами из общей рейтинг-таблицы
3. Итоговая рекомендация содержит ровно 3 товара для каждого пользователя

## Использование
### Запуск

Валидационное разбиение

`data_train, data_val, gt_val = get_validation_split(df=df_train,timestamp_to_split="2020-02-16")`

Анализ популярности

`popular_products = data_train.groupby(['product_id']).size().sort_values(ascending=False)`

Построение профилей пользователей

`user_brands = pd.pivot_table(df_test,index=['user_id'],values=['brand'],aggfunc=lambda x: np.array(list(dict.fromkeys(x)))[:3])`

`user_avg_price = df_test.groupby(['user_id'])['price'].mean()`

Создание рекомендаций

`recommendations = []`

`for user_id in df_test['user_id'].unique():`

`personalized = filter_by_brand_and_price(user_id, user_brands, user_avg_price)`

`top_3 = personalized[:3] if len(personalized) >= 3 else personalized + list(popular_products[:3-len(personalized)])`

`recommendations.append(top_3)`

### Формат вывода
| user_id | product_id |
|---------|-----------|
| 455871375 | 1005100 1004767 100068488 |
| 435497056 | 1005115 1002544 1005129 |
| ... | ... |

Каждая строка содержит ID пользователя и пространство-разделенный список из 3 рекомендуемых товаров.

## Результаты

Система демонстрирует значительное улучшение по сравнению с базовым подходом (рекомендация только популярных товаров):

- Учет предпочтений пользователя по брендам повышает релевантность рекомендаций
- Фильтрация по ценовому диапазону обеспечивает соответствие платежеспособности пользователя
- Исключение уже просмотренных товаров избегает дублирования рекомендаций
- Гибридный подход гарантирует полноту списка рекомендаций для всех пользователей
